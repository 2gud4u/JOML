{"name":"Joml","tagline":"A Java-based math library for OpenGL rendering calculations","body":"Design goals\r\n------------\r\n\r\nThe goal of JOML is to provide easy-to-use, feature-rich and efficient linear algebra operations, needed by any 3D application. At the same time, JOML tries to pose the lowest possible requirements to an execution environment by being compatible with Java 1.4 and not making use of JNI.\r\n\r\nIf you like to know more about JOML's design, see the corresponding [Wiki page](https://github.com/JOML-CI/JOML/wiki/Design).\r\n\r\nVector arithmetic\r\n-----------------\r\nAll operations in JOML are designed to modify the object on which the operation is invoked. This helps in completely eliminating any object allocations, which the client could otherwise not control and which impact the GC performance resulting in small hickups.\r\nThe client is responsible to allocate the needed working objects.\r\n```Java\r\nVector3f v = new Vector3f(0.0f, 1.0f, 0.0f);\r\nVector3f a = new Vector3f(1.0f, 0.0f, 0.0f);\r\n// v = v + a\r\nv.add(a);\r\n// a = a x v\r\na.cross(v);\r\n// a = a/|a|\r\na.normalize();\r\n```\r\n\r\nMatrix API\r\n----------\r\nUsing JOML you can build matrices out of basic transformations, such as scale, translate and rotate, using a fluent interface style. All such operations directly modify the matrix instance on which they are invoked.\r\nThe following example builds a transformation matrix which effectively first scales all axes by 0.5\r\nand then translates x by 2.0:\r\n```Java\r\nVector3f v = ...;\r\nnew Matrix4f().translate(2.0f, 0.0f, 0.0f)\r\n              .scale(0.5f);\r\n              .transform(v);\r\n// v is now transformed by the specified transformation\r\n```\r\n\r\nCommon transformation idioms, such as rotating about a given axis using a specific rotation center, can be expressed in a simple way. The following example rotates the point (0, 4, 4) about the x-axis and uses (0, 3, 4) as the rotation center:\r\n```Java\r\nVector3f center = new Vector3f(0.0f, 3.0f, 4.0f);\r\nVector3f pointToRotate = new Vector3f(0.0f, 4.0f, 4.0f);\r\nnew Matrix4f().translate(center)\r\n              .rotate((float) Math.toRadians(90.0f), 1.0f, 0.0f, 0.0f)\r\n              .translate(center.negate())\r\n              .transform(pointToRotate);\r\n```\r\nThe vector *pointToRotate* will now represent (0, 3, 5).\r\n\r\nPost-multiplication\r\n-------------------\r\nAll transformation operations in the matrix and quaternion classes act in the same way as OpenGL and GLU by post-multiplying the operation's result to the object on which they are invoked. This allows to chain multiple transformations in the same way as with OpenGL's legacy matrix stack operations, and allows to decompose the resulting effective matrix as a decomposition of multiple matrix multiplications.\r\nOne such common decomposition are the _projection_ and _modelview_ matrices, written as: `P * MV`. The _modelview_ matrix of course can be further decomposed into individual matrix multiplications, as fas as this seems necessary.\r\n\r\nWhen invoking transformation methods in JOML's matrix classes, a convenient way now is to think of Java's _dot_ operator as a matrix multiplication. If multiple matrix operations are chained after one another, as shown in the above example, each individual operation/method creates its matrix which is then post-multiplied to the matrices built before.\r\n\r\nIn addition to the post-multiplying methods, there are still ways to set a matrix or quaternion to a given transformation regardless of what that matrix or quaternion was before:\r\n\r\n```Java\r\nMatrix m = new Matrix();\r\nVector3f point = new Vector3f(1.0f, 2.0f, 3.0f);\r\nVector3f offset = new Vector3f(1.0f, 0.0f, 0.0f);\r\n...\r\nm.translation(offset).transform(point);\r\n```\r\nIn the above example, the matrix _m_ is being set to a translation, instead of applying the translation to it.\r\nThese methods are useful when the same matrix is being used in a sequence of consecutive operations or repeatedly in a loop without having to set it to the identity each time.\r\n\r\nBuilding a camera transformation\r\n--------------------------------\r\nIn the same way that you can concatenate multiple simple affine transformations, you can use the methods perspective(), frustum() and ortho() to specify a perspective or orthogonal projection and lookAt() to create an orthonormal transformation that mimics a camera *looking* at a given point.\r\nThose methods resemble the ones known from GLU and act in the same way (i.e. they apply their transformations to an already existing transformation):\r\n```Java\r\nMatrix4f m = new Matrix4f()\r\n     .perspective((float) Math.toRadians(45.0f), 1.0f, 0.01f, 100.0f)\r\n     .lookAt(0.0f, 0.0f, 10.0f,\r\n             0.0f, 0.0f, 0.0f,\r\n             0.0f, 1.0f, 0.0f);\r\n// the camera transformation is now in m\r\n```\r\nThe above transformation can then be used as a \"view-projection\" matrix in a shader.\r\n\r\nComputation result\r\n------------------\r\nUsually, instance methods operate on the object (matrix, vector, quaternion) on which they are invoked by writing the computation result back into that object. Most of the methods however also allow to specify another destination object to write the result into. This is useful if you do not want to overwrite the original object with the computation result.\r\nThis can be useful for computing the view-projection matrix and its inverse in one go:\r\n```Java\r\nMatrix4f viewProj = new Matrix4f();\r\nMatrix4f invViewProj = new Matrix4f();\r\nviewProj.perspective((float) Math.toRadians(45.0f), 1.0f, 0.01f, 100.0f)\r\n        .lookAt(0.0f, 1.0f, 3.0f,\r\n                0.0f, 0.0f, 0.0f,\r\n                0.0f, 1.0f, 0.0f)\r\n        .invert(invViewProj);\r\n```\r\nThe *invViewProj* matrix now contains the inverse of the *viewProj* matrix, but the latter is still intact.\r\n\r\nMethod chaining and context switching\r\n-------------------------------------\r\nWith the possibility of chaining multiple transformations and writing computation results in designated _destination_ objects, it is convenient to be able to switch the context object in order to apply further operations on different objects.\r\nThis can be done easily using the _with()_ methods.\r\nThe following example shows how a spherical linear interpolation can be built and the result be used to transform a vector:\r\n\r\n```Java\r\nQuaternion q1 = ...;\r\nQuaternion q2 = ...;\r\nQuaternion dest = new Quaternion();\r\nVector3f v = ...;\r\nq1.slerp(q2, alpha, dest).with(dest).transform(v);\r\n```\r\nHere, the spherical linear interpolation is computed using the Quaternion's _slerp()_ method taking a _dest_ parameter. This method is preferred because it does not change the original context quaternion _q1_.\r\nNow, because the context after this call is still _q1_, the _with()_ method is used to switch over to _dest_ and then transform the vector _v_ by this interpolated quaternion.\r\n\r\nUsing the same method you can also specify both the view and projection matrices in one go:\r\n```Java\r\nMatrix4f proj = new Matrix4f();\r\nMatrix4f view = new Matrix4f();\r\nproj.perspective((float) Math.toRadians(45.0f), 1.0f, 0.01f, 100.0f)\r\n    .with(view).lookAt(0.0f, 1.0f, 5.0f,\r\n                       0.0f, 0.0f, 0.0f,\r\n                       0.0f, 1.0f, 0.0f);\r\n```\r\n\r\nUsing with [LWJGL](https://github.com/LWJGL/lwjgl3)\r\n---------------------------------------------------\r\nJOML can be used together with LWJGL to build a transformation matrix and set it as a uniform mat4 in a shader. For this, the Matrix4f class provides a method to transfer a matrix into a Java NIO FloatBuffer, which can then be used by LWJGL when calling into OpenGL:\r\n```Java\r\nFloatBuffer fb = BufferUtils.createFloatBuffer(16);\r\nnew Matrix4f().perspective((float) Math.toRadians(45.0f), 1.0f, 0.01f, 100.0f)\r\n              .lookAt(0.0f, 0.0f, 10.0f,\r\n                      0.0f, 0.0f, 0.0f,\r\n                      0.0f, 1.0f, 0.0f)\r\n              .get(fb);\r\nglUniformMatrix4fv(mat4Location, false, fb);\r\n```\r\nThe above example first creates a transformation matrix and then uploads that matrix to a uniform variable of the active shader program using the LWJGL 3 method [*glUniformMatrix4fv*](http://javadoc.lwjgl.org/org/lwjgl/opengl/GL20.html#glUniformMatrix4fv%28int,%20boolean,%20java.nio.FloatBuffer%29).\r\n\r\nIf you prefer not to use shaders but the fixed-function pipeline and want to use JOML to build the transformation matrices, you can do so. Instead of uploading the matrix as a shader uniform you can then use the OpenGL API call [*glLoadMatrixf()*](http://javadoc.lwjgl.org/org/lwjgl/opengl/GL11.html#glLoadMatrixf%28java.nio.FloatBuffer%29) provided by LWJGL to set a JOML matrix as the current matrix in OpenGL's matrix stack:\r\n```Java\r\nFloatBuffer fb = BufferUtils.createFloatBuffer(16);\r\nMatrix4f m = new Matrix4f();\r\nm.setPerspective((float) Math.toRadians(45.0f), 1.0f, 0.01f, 100.0f).get(fb);\r\nglMatrixMode(GL_PROJECTION);\r\nglLoadMatrixf(fb);\r\nm.setLookAt(0.0f, 0.0f, 10.0f,\r\n            0.0f, 0.0f, 0.0f,\r\n            0.0f, 1.0f, 0.0f).get(fb);\r\nglMatrixMode(GL_MODELVIEW);\r\nglLoadMatrixf(fb);\r\n```\r\n\r\nStaying allocation-free\r\n-----------------------\r\nJOML is designed to be completely allocation-free for all methods. That means JOML will never allocate Java objects on the heap unless you as the client specifically requests to do so via the *new* keyword when creating a new matrix or vector or calling the *toString()* method on them.\r\n\r\n*JOML also does not allocate any unexpected internal helper/temporary/working objects itself, neither in instance nor static fields, thus giving you full control over object allocations.*\r\n\r\nSince you have to create a matrix or a vector at some point in order to make any computations with JOML on them, you are advised to do so once at the initialization of your program. Those objects will then be the *working memory/objects* for JOML. These working objects can then be reused in the hot path of your application without incurring any additional allocations. The following example shows a typical usecase with LWJGL:\r\n\r\n```Java\r\nFloatBuffer fb;\r\nMatrix4f m;\r\n\r\nvoid init() {\r\n  fb = BufferUtils.createFloatBuffer(16);\r\n  m = new Matrix4f();\r\n  ...\r\n}\r\n\r\nvoid frame() {\r\n  ...\r\n  // compute view-projection matrix\r\n  m.identity()\r\n   .perspective((float) Math.toRadians(45.0f), (float)width/height, 0.01f, 100.0f)\r\n   .lookAt(0.0f, 0.0f, 10.0f,\r\n           0.0f, 0.0f, 0.0f,\r\n           0.0f, 1.0f, 0.0f);\r\n  // possibly apply more model transformations\r\n  m.rotateY(angle);\r\n  // get matrix into FloatBuffer and upload to OpenGL\r\n  m.get(fb);\r\n  glUniformMatrix4fv(mat4Location, false, fb);\r\n  ...\r\n}\r\n```\r\nIn the example above, a single Matrix4f is allocated during some initialization time when the *init()* method is called. Then each *frame()* we reinitialize the same matrix with the *identity()* and recompute the camera transformation based on some other parameters.\r\n\r\nMultithreading\r\n--------------\r\nDue to JOML not using any internal temporary objects during any computations, you can use JOML in a multithreaded application. You only need to make sure not to call a method modifying the same matrix or vector from two different threads. Other than that, there is no internal or external synchronization necessary.\r\n\r\nMatrix stack\r\n------------\r\nJOML also features an interface that resembles the matrix stack from legacy OpenGL.\r\nThis allows you to use all of the legacy OpenGL matrix stack operations even in modern OpenGL applications,\r\nbut without the otherwise necessary JNI calls into the graphics driver.\r\n*Note that JOML does not interface in any way with the OpenGL API. It merely provides matrix and vector arithmetics.*\r\n```Java\r\nMatrixStack s = new MatrixStack(2);\r\nMatrix4f result = new Matrix4f();\r\ns.translate(2.0f, 0.0f, 0.0f);\r\ns.pushMatrix();\r\n{\r\n  s.scale(0.5f, 0.5f, 0.5f);\r\n  s.get(result);\r\n  // do something with result\r\n}\r\ns.popMatrix();\r\ns.rotate((float) Math.toRadians(45.0f), 0.0f, 0.0f, 1.0f);\r\ns.get(result);\r\n// do something with result\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}