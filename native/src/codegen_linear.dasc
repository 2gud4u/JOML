#include <stdlib.h>
#include <Windows.h>

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"
#include "codegen.h"
#include "opcodes.h"

|.arch x64
|.section code
|.globals GLOB_
|.actionlist actionlist

#ifndef _MM_SHUFFLE
#define _MM_SHUFFLE(x,y,z,w) ((z << 6) | (y <<4) | (x << 2) | (w))
#endif

static void matrix_transpose(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in first (xmm8-xmm11)
  // will store in either first or second (xmm12-xmm15)
  | movaps xmm0, xmm8
  | movaps xmm2, xmm0
  | movaps xmm1, xmm9
  | shufps xmm0, xmm1, 0x88
  | shufps xmm2, xmm1, 0xdd
  | movaps xmm3, xmm10
  | movaps xmm5, xmm3
  | movaps xmm6, xmm11
  | shufps xmm3, xmm6, 0x88
  | shufps xmm5, xmm6, 0xdd
  | movaps xmm1, xmm0
  | shufps xmm0, xmm3, 0x88
  | movaps xmm4, xmm2
  | shufps xmm2, xmm5, 0x88
  | shufps xmm1, xmm3, 0xdd
  | shufps xmm4, xmm6, 0xdd
  if (!storeIntoSecond) {
    // store back into first
    | movaps xmm8, xmm0
    | movaps xmm9, xmm2
    | movaps xmm10, xmm1
    | movaps xmm11, xmm4
  } else {
    // store back into second
    | movaps xmm12, xmm0
    | movaps xmm13, xmm2
    | movaps xmm14, xmm1
    | movaps xmm15, xmm4
  }
}

static void copy_first_from_second(dasm_State** Dst) {
  | movaps xmm8, xmm12
  | movaps xmm9, xmm13
  | movaps xmm10, xmm14
  | movaps xmm11, xmm15
}

static void load_second(dasm_State** Dst) {
  | mov r8, [rcx]
  | add rcx, 16
  | movaps xmm12, [r8]
  | movaps xmm13, [r8+4*4]
  | movaps xmm14, [r8+4*8]
  | movaps xmm15, [r8+4*12]
}

static void load_first(dasm_State** Dst) {
  | mov r8, [rcx]
  | add rcx, 16
  | movaps xmm8, [r8]
  | movaps xmm9, [r8+4*4]
  | movaps xmm10, [r8+4*8]
  | movaps xmm11, [r8+4*12]
}

static void store_second(dasm_State** Dst) {
  | mov r8, [rcx]
  | add rcx, 16
  | movaps [r8], xmm12
  | movaps [r8+4*4], xmm13
  | movaps [r8+4*8], xmm14
  | movaps [r8+4*12], xmm15
}

static void store_first(dasm_State** Dst) {
  | mov r8, [rcx]
  | add rcx, 16
  | movaps [r8], xmm8
  | movaps [r8+4*4], xmm9
  | movaps [r8+4*8], xmm10
  | movaps [r8+4*12], xmm11
}

static void linearProduct(dasm_State** Dst) {
  // vector is in xmm0, matrix in xmm8-xmm11
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | movaps xmm2, xmm0
  | shufps xmm2, xmm2, _MM_SHUFFLE(1, 1, 1, 1)
  | movaps xmm3, xmm0
  | shufps xmm3, xmm3, _MM_SHUFFLE(2, 2, 2, 2)
  | movaps xmm4, xmm0
  | shufps xmm4, xmm4, _MM_SHUFFLE(3, 3, 3, 3)
  | movaps xmm0, xmm8
  | mulps xmm0, xmm1
  | movaps xmm1, xmm9
  | mulps xmm1, xmm2
  | movaps xmm2, xmm10
  | mulps xmm2, xmm3
  | movaps xmm3, xmm11
  | mulps xmm3, xmm4
  | addps xmm0, xmm1
  | addps xmm2, xmm3
  | addps xmm0, xmm2
}

static void matrix_mul_matrix(dasm_State** Dst, char storeIntoSecond) {
  // requires:
  // left matrix in xmm8-xmm11 (aka. first)
  // right matrix in xmm12-xmm15 (aka. second)
  // will store in either first or second
  for (int i = 0; i < 4; i++) {
    // load column/vector from second
    if (i == 0) {
      | movaps xmm0, xmm12
    } else if (i == 1) {
      | movaps xmm0, xmm13
    } else if (i == 2) {
      | movaps xmm0, xmm14
    } else if (i == 3) {
      | movaps xmm0, xmm15
    }
    linearProduct(Dst);
    if (!storeIntoSecond) {
      // store into first
      if (i == 0) {
        | movaps xmm5, xmm0
      } else if (i == 1) {
        | movaps xmm6, xmm0
      } else if (i == 2) {
        | movaps xmm7, xmm0
      } else if (i == 3) {
        | movaps xmm8, xmm5
        | movaps xmm9, xmm6
        | movaps xmm10, xmm7
        | movaps xmm11, xmm0
      }
    } else {
      // store into second
      if (i == 0) {
        | movaps xmm12, xmm0
      } else if (i == 1) {
        | movaps xmm13, xmm0
      } else if (i == 2) {
        | movaps xmm14, xmm0
      } else if (i == 3) {
        | movaps xmm15, xmm0
      }
    }
  }
}

static void rotateX(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | add rcx, 4
  | movss xmm1, dword [rcx] // cos
  | add rcx, 12
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | xorps xmm2, xmm2
  | subps xmm2, xmm0 // -sin
  | movaps xmm3, xmm9
  | mulps xmm3, xmm1 // m1X * rm11
  | movaps xmm4, xmm10
  | mulps xmm4, xmm0 // m2X * rm12
  | addps xmm3, xmm4
  | movaps xmm4, xmm9
  | mulps xmm4, xmm2 // m1X * rm21
  | movaps xmm5, xmm10
  | mulps xmm5, xmm1 // m2X * rm22
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm9, xmm3
    | movaps xmm10, xmm4
  } else {
    | movaps xmm12, xmm8
    | movaps xmm13, xmm3
    | movaps xmm14, xmm4
    | movaps xmm15, xmm11
  }
}

static void rotateY(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | add rcx, 4
  | movss xmm1, dword [rcx] // cos
  | add rcx, 12
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | xorps xmm2, xmm2
  | subps xmm2, xmm0 // -sin
  | movaps xmm3, xmm8
  | mulps xmm3, xmm1 // m0X * rm00
  | movaps xmm4, xmm10
  | mulps xmm4, xmm2 // m2X * rm02
  | addps xmm3, xmm4
  | movaps xmm4, xmm8
  | mulps xmm4, xmm0 // m0X * rm20
  | movaps xmm5, xmm10
  | mulps xmm5, xmm1 // m2X * rm22
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm8, xmm3
    | movaps xmm10, xmm4
  } else {
    | movaps xmm12, xmm3
    | movaps xmm13, xmm9
    | movaps xmm14, xmm4
    | movaps xmm15, xmm11
  }
}

static void rotateZ(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | add rcx, 4
  | movss xmm1, dword [rcx] // cos
  | add rcx, 12
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | xorps xmm2, xmm2
  | subps xmm2, xmm0 // -sin
  | movaps xmm3, xmm8
  | mulps xmm3, xmm1 // m0X * rm00
  | movaps xmm4, xmm9
  | mulps xmm4, xmm0 // m1X * rm01
  | addps xmm3, xmm4
  | movaps xmm4, xmm8
  | mulps xmm4, xmm2 // m0X * rm10
  | movaps xmm5, xmm9
  | mulps xmm5, xmm1 // m1X * rm11
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm8, xmm3
    | movaps xmm9, xmm4
  } else {
    | movaps xmm12, xmm3
    | movaps xmm13, xmm4
    | movaps xmm14, xmm10
    | movaps xmm15, xmm11
  }
}

static void matrix_identity(dasm_State** Dst) {
  // requires matrix to be in first (xmm8-xmm11)
  // will store in first
  | mov r9, 0x3f800000 // int representation of 1.0f
  | movd xmm8, r9
  | movaps xmm9, xmm8
  | shufps xmm9, xmm9, 0x93
  | movaps xmm10, xmm9
  | shufps xmm10, xmm10, 0x93
  | movaps xmm11, xmm10
  | shufps xmm11, xmm11, 0x93
}

static void prologue(dasm_State** Dst) {
  | push rbp
  | mov rbp, rsp
  // save all non-volatile registers that we use
  | sub rsp, 4*16*10 // xmm6-xmm15 are non-volatile
  | movdqu [rsp], xmm6
  | movdqu [rsp+4*16], xmm7
  | movdqu [rsp+4*16*2], xmm8
  | movdqu [rsp+4*16*3], xmm9
  | movdqu [rsp+4*16*4], xmm10
  | movdqu [rsp+4*16*5], xmm11
  | movdqu [rsp+4*16*6], xmm12
  | movdqu [rsp+4*16*7], xmm13
  | movdqu [rsp+4*16*8], xmm14
  | movdqu [rsp+4*16*9], xmm15
}

static void epilogue(dasm_State** Dst) {
  | movdqu xmm6, [rsp]
  | movdqu xmm7, [rsp+4*16]
  | movdqu xmm8, [rsp+4*16*2]
  | movdqu xmm9, [rsp+4*16*3]
  | movdqu xmm10, [rsp+4*16*4]
  | movdqu xmm11, [rsp+4*16*5]
  | movdqu xmm12, [rsp+4*16*6]
  | movdqu xmm13, [rsp+4*16*7]
  | movdqu xmm14, [rsp+4*16*8]
  | movdqu xmm15, [rsp+4*16*9]
  | add rsp, 4*16*10
  | mov rsp, rbp
  | pop rbp
  | ret
}

batch_func_t codegen(const unsigned char* opcodes, int opcodesLength, size_t* codeSize) {
  dasm_State* state;
  dasm_State** Dst = &state;
  int status;
  void* code;
  DWORD dwOld;
  void* global_labels[GLOB__MAX];
  dasm_init(&state, DASM_MAXSECTION);
  dasm_setupglobal(&state, global_labels, GLOB__MAX);
  dasm_setup(&state, actionlist);
  prologue(Dst);
  for (int i = 0; i < opcodesLength; i++) {
    unsigned char opcode = opcodes[i];
    char toSecond = (opcode & OPCODE_MASK_TO_SECOND) != 0;
    switch (opcode) {
    case OPCODE_MATRIX_MUL_MATRIX:
      matrix_mul_matrix(&state, toSecond); break;
    case OPCODE_MATRIX_TRANSPOSE:
      matrix_transpose(&state, toSecond); break;
    case OPCODE_MATRIX_IDENTITY:
      matrix_identity(&state); break;
    case OPCODE_ROTATEX:
      rotateX(&state, toSecond); break;
    case OPCODE_ROTATEY:
      rotateY(&state, toSecond); break;
    case OPCODE_ROTATEZ:
      rotateZ(&state, toSecond); break;
    case OPCODE_STORE_FIRST:
      store_first(&state); break;
    case OPCODE_STORE_SECOND:
      store_second(&state); break;
    case OPCODE_LOAD_FIRST:
      load_first(&state); break;
    case OPCODE_LOAD_SECOND:
      load_second(&state); break;
    case OPCODE_COPY_FIRST_FROM_SECOND:
      copy_first_from_second(&state); break;
    default:
      break;
    }
  }
  epilogue(Dst);
  status = dasm_link(&state, codeSize);
  code = VirtualAlloc(0, *codeSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  status = dasm_encode(&state, code);
  VirtualProtect(code, *codeSize, PAGE_EXECUTE, &dwOld);
  FlushInstructionCache(GetCurrentProcess(), code, *codeSize);
  dasm_free(&state);
  return (batch_func_t) code;
}

int free_code(void* code, size_t codeSize) {
  return VirtualFree(code, 0, MEM_RELEASE);
}
