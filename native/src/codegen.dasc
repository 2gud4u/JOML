#include <stdlib.h>
#include <Windows.h>

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"
#include "codegen.h"

|.arch x64
|.section code
|.globals GLOB_
|.actionlist actionlist

#ifndef _MM_SHUFFLE
#define _MM_SHUFFLE(x,y,z,w) ((z << 6) | (y <<4) | (x << 2) | (w))
#endif

/**
 * Transpose a matrix using raw SSE shufps instructions.
 */
static void matrix_transpose(dasm_State** Dst) {
  |->matrix_transpose:
  // obtain matrix from [rcx]
  | mov r8, [rcx]
  | add rcx, sizeof(char*)
  // shuffle around a bit
  | movaps xmm0, [r8]
  | movaps xmm2, xmm0
  | movaps xmm1, [r8+4*4]
  | shufps xmm0, xmm1, 0x88
  | shufps xmm2, xmm1, 0xdd
  | movaps xmm3, [r8+8*4]
  | movaps xmm5, xmm3
  | movaps xmm6, [r8+12*4]
  | shufps xmm3, xmm6, 0x88
  | shufps xmm5, xmm6, 0xdd
  | movaps xmm1, xmm0
  | shufps xmm0, xmm3, 0x88
  | movaps xmm4, xmm2
  | shufps xmm2, xmm5, 0x88
  | shufps xmm1, xmm3, 0xdd
  | shufps xmm4, xmm6, 0xdd
  // store back into matrix at [r8]
  | movaps [r8], xmm0
  | movaps [r8+4*4], xmm2
  | movaps [r8+8*4], xmm1
  | movaps [r8+12*4], xmm4
}

static void linearProduct(dasm_State** Dst) {
  // create xmm1-xmm4 containing the i'th column of the second matrix to be multiplied by the first matrix
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | movaps xmm2, xmm0
  | shufps xmm2, xmm2, _MM_SHUFFLE(1, 1, 1, 1)
  | movaps xmm3, xmm0
  | shufps xmm3, xmm3, _MM_SHUFFLE(2, 2, 2, 2)
  | movaps xmm4, xmm0
  | shufps xmm4, xmm4, _MM_SHUFFLE(3, 3, 3, 3)
  | movaps xmm0, [r8]
  | mulps xmm0, xmm1
  | movaps xmm1, [r8+4*4]
  | mulps xmm1, xmm2
  | movaps xmm2, [r8+4*8]
  | mulps xmm2, xmm3
  | movaps xmm3, [r8+4*12]
  | mulps xmm3, xmm4
  | addps xmm0, xmm1
  | addps xmm2, xmm3
  | addps xmm0, xmm2
  // result is in xmm0
}

static void mul_matrix_matrix(dasm_State** Dst) {
  |->mul_matrix_matrix:
  // obtain first matrix
  | mov r8, [rcx]
  | add rcx, 8
  // obtain second matrix
  | mov r9, [rcx]
  | add rcx, 8
  for (int i = 0; i < 4; i++) {
    // get i-th column of second matrix
    | movaps xmm0, [r9+4*4*i]
    linearProduct(Dst);
    /* We must be careful to not overwrite the destination
       matrix with the column results, since that matrix
       is needed in subsequence linearProducts.
       Luckily, we have 8 XMM registers, and can 
       buffer the first three results into them and
       during the last iteration we store all of them
       including xmm0 of that computation into the destination
       matrix. */
    if (i == 0) {
      | movaps xmm5, xmm0
    } else if (i == 1) {
      | movaps xmm6, xmm0
    } else if (i == 2) {
      | movaps xmm7, xmm0
    } else if (i == 3) {
      | movaps [r8], xmm5
      | movaps [r8+4*4], xmm6
      | movaps [r8+8*4], xmm7
      | movaps [r8+12*4], xmm0
    }
  }
}

/**
 * Fast matrix-vector multiplication.
 * 
 * Adapted from GCC intrinsics of:
 * http://stackoverflow.com/questions/14967969/efficient-4x4-matrix-vector-multiplication-with-sse-horizontal-add-and-dot-prod
 */
static void mul_matrix_vector(dasm_State** Dst) {
  |->mul_matrix_vector:
  // obtain vector
  | mov r8, [rcx]
  | add rcx, 8
  | movaps xmm0, [r8]

  // create xmm1-xmm4 containing the vectors to be multiplied
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | movaps xmm2, xmm0
  | shufps xmm2, xmm2, _MM_SHUFFLE(1, 1, 1, 1)
  | movaps xmm3, xmm0
  | shufps xmm3, xmm3, _MM_SHUFFLE(2, 2, 2, 2)
  | movaps xmm4, xmm0
  | shufps xmm4, xmm4, _MM_SHUFFLE(3, 3, 3, 3)

  // obtain matrix
  | mov r9, [rcx]
  | add rcx, sizeof(char*)

  // load first matrix column and multiply with xmm1
  | movaps xmm0, [r9]
  | mulps xmm0, xmm1
  // load second matrix column and multiply with xmm2
  | movaps xmm1, [r9+4*4]
  | mulps xmm1, xmm2
  // load third matrix column and multiply with xmm3
  | movaps xmm2, [r9+4*8]
  | mulps xmm2, xmm3
  // load fourth matrix column and multiply with xmm4
  | movaps xmm3, [r9+4*12]
  | mulps xmm3, xmm4
  // now the results are in xmm0-xmm3 and need to be added
  | addps xmm0, xmm1
  | addps xmm2, xmm3
  | addps xmm0, xmm2

  // write final result in xmm0 back into vector
  | movaps [r8], xmm0
}

static void translation_rotate_scale(dasm_State** Dst) {
  |->translation_rotate_scale:
  // obtain matrix
  | mov r8, [rcx]
  | add rcx, 16
  // store translation in xmm0
  | movaps xmm0, [rcx]
  | add rcx, sizeof(float)*4
  // store quaternion in xmm1
  | movaps xmm1, [rcx]
  | add rcx, sizeof(float)*4
  // store scale in xmm2
  | movaps xmm2, [rcx]
  | add rcx, sizeof(float)*4
  
  // TODO: Here we need to actually do what Matrix4f.translationRotateScale() does,
  //       just only better.
}

batch_func_t codegen(const char* opcodes, int opcodesLength) {
  dasm_State* state;
  dasm_State** Dst = &state;
  int status;
  void* code;
  int next_pc = 0;
  size_t code_size;
  DWORD dwOld;
  void* global_labels[GLOB__MAX];
  char op_generated[] = {0, 0, 0, 0, 0};
  dasm_init(&state, DASM_MAXSECTION);
  dasm_setupglobal(&state, global_labels, GLOB__MAX);
  dasm_setup(&state, actionlist);
  dasm_growpc(&state, opcodesLength);
  for (int i = 0; i < opcodesLength; i++) {
    switch (opcodes[i]) {
    case 0x01: // OPCODE_MATRIX_MUL_MATRIX
      // tell the matrix function where to jump to
      // in order to execute the next operation
      | mov rdx, =>next_pc
      | jmp ->mul_matrix_matrix
      if (!op_generated[0]) {
        mul_matrix_matrix(&state);
        // jump to next operation
        | jmp rdx
        op_generated[0] = 1;
      }
      // define the label that we just jumped to above
      |=>next_pc:
      // use a new fresh label "index" for the next label
      next_pc++;
      break;
    case 0x02: // OPCODE_MATRIX_MUL_VECTOR
      | mov rdx, =>next_pc
      | jmp ->mul_matrix_vector
      if (!op_generated[1]) {
        mul_matrix_vector(&state);
        // jump to next operation
        | jmp rdx
        op_generated[1] = 1;
      }
      |=>next_pc:
      next_pc++;
      break;
    case 0x03: // OPCODE_MATRIX_TRANSPOSE
      | mov rdx, =>next_pc
      | jmp ->matrix_transpose
      if (!op_generated[2]) {
        matrix_transpose(&state);
        // jump to next operation
        | jmp rdx
        op_generated[2] = 1;
      }
      |=>next_pc:
      next_pc++;
      break;
    case 0x04: // OPCODE_MATRIX_INVERT
      // Not yet implemented!
      break;
    case 0x05: // OPCODE_TRANSLATION_ROTATE_SCALE
      | mov rdx, =>next_pc
      | jmp ->translation_rotate_scale
      if (!op_generated[4]) {
        translation_rotate_scale(&state);
        // jump to next operation
        | jmp rdx
        op_generated[4] = 1;
      }
      |=>next_pc:
      next_pc++;
      break;
    default:
      break;
    }
  }
  | ret
  status = dasm_link(&state, &code_size);
  code = VirtualAlloc(0, code_size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
  status = dasm_encode(&state, code);
  VirtualProtect(code, code_size, PAGE_EXECUTE, &dwOld);
  FlushInstructionCache(GetCurrentProcess(), code, code_size);
  dasm_free(&state);
  return (batch_func_t) code;
}
