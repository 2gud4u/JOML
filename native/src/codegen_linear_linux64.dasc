#include <stdlib.h>
#include <sys/mman.h>

#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"
#include "codegen.h"
#include "opcodes.h"

|.arch x64
|.section code
|.globals GLOB_
|.actionlist actionlist

#ifndef _MM_SHUFFLE
#define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \
 (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | (fp0))
#endif

/**
 * Reference: http://www.gamedev.net/topic/621951-sse-4x4-matrix-transpose-and-invert/
 */
static void matrix_invert(dasm_State** Dst, char storeIntoSecond) {
  // Make (0, -0, -0, 0) ready in stack at [r8]
  | mov r8, rsp
  | and r8, -16
  | sub r8, 16
  | mov dword [r8], 0x0
  | mov dword [r8+4], 0x80000000
  | mov dword [r8+8], 0x80000000
  | mov dword [r8+12], 0x0
  // Save xmm8, xmm9, xmm10 to stack at [r9], [r9+16], [r9+32]
  | mov r9, r8
  | sub r9, 16*3
  | movaps [r9], xmm8 // <- save xmm8 to stack, because we need it for computations!
  | movaps [r9+16], xmm9
  | movaps [r9+32], xmm10

  // Vec4 const & m11 = _mm_movelh_ps(c0, c1);
  // Vec4 const & m21 = _mm_movehl_ps(c1, c0);
  // Vec4 const & m12 = _mm_movelh_ps(c2, c3);
  // Vec4 const & m22 = _mm_movehl_ps(c3, c2);

  | movaps xmm0, xmm8
  | movlhps xmm0, xmm9
  | movaps xmm1, xmm9
  | movhlps xmm1, xmm8
  | movaps xmm2, xmm10
  | movlhps xmm2, xmm11
  | movaps xmm3, xmm11
  | movhlps xmm3, xmm10

  // inv2x2(m): return adj2x2(m) * det2x2(m).rcp();
  // adj2x2(m): _mm_xor_ps(m.swizzle<3,1,2,0>(), (0.0f, -0.0f, -0.0f, 0.0f));
  // det2x2(m): temp = m.swizzle<0,0,1,1>() * m.swizzle<3,3,2,2>();
  //            return _mm_sub_ps(_mm_unpacklo_ps(temp, temp), _mm_unpackhi_ps(temp, temp));

  // inv2x2(m11 = xmm0):
    // adj2x2(m11 = xmm0):
  | movaps xmm4, xmm0
  | shufps xmm4, xmm4, _MM_SHUFFLE(3, 1, 2, 0)
  | movaps xmm5, [r8] // <- load (0, -0, -0, 0)
  | xorps xmm4, xmm5 // <- _mm_xor_ps(m.swizzle<3,1,2,0>(), (0.0f, -0.0f, -0.0f, 0.0f));
    // det2x2(m11 = xmm0):
  | movaps xmm5, xmm0
  | shufps xmm5, xmm5, _MM_SHUFFLE(0, 0, 1, 1)
  | movaps xmm6, xmm0
  | shufps xmm6, xmm6, _MM_SHUFFLE(3, 3, 2, 2)
  | mulps xmm5, xmm6 // <- temp = m.swizzle<0,0,1,1>() * m.swizzle<3,3,2,2>();
  | movaps xmm6, xmm5
  | unpcklps xmm5, xmm5
  | unpckhps xmm6, xmm6
  | subps xmm5, xmm6 // <- _mm_sub_ps(_mm_unpacklo_ps(temp, temp), _mm_unpackhi_ps(temp, temp));
  | rcpps xmm5, xmm5 // <- det2x2(m).rcp();
  | mulps xmm4, xmm5 // <- inv11 = inv2x2(m11 = xmm0)

  // free: xmm5, xmm6, xmm7

  // inv2x2(m22 = xmm3):
    // adj2x2(m22 = xmm3):
  | movaps xmm5, xmm3
  | shufps xmm5, xmm5, _MM_SHUFFLE(3, 1, 2, 0)
  | movaps xmm6, [r8] // <- load (0, -0, -0, 0)
  | xorps xmm5, xmm6 // <- _mm_xor_ps(m.swizzle<3,1,2,0>(), (0.0f, -0.0f, -0.0f, 0.0f));
    // det2x2(m22 = xmm3):
  | movaps xmm6, xmm3
  | shufps xmm6, xmm6, _MM_SHUFFLE(0, 0, 1, 1)
  | movaps xmm7, xmm3
  | shufps xmm7, xmm7, _MM_SHUFFLE(3, 3, 2, 2)
  | mulps xmm6, xmm7 // <- temp = m.swizzle<0,0,1,1>() * m.swizzle<3,3,2,2>();
  | movaps xmm7, xmm6
  | unpcklps xmm6, xmm6
  | unpckhps xmm7, xmm7
  | subps xmm6, xmm7 // <- _mm_sub_ps(_mm_unpacklo_ps(temp, temp), _mm_unpackhi_ps(temp, temp));
  | rcpps xmm6, xmm6 // <- det2x2(m).rcp();
  | mulps xmm5, xmm6 // <- inv22 = inv2x2(m22 = xmm3)

  // free: xmm6, xmm7

  // mul2x2(a, b): b.swizzle<0,0,2,2>() * _mm_movelh_ps(a, a) + b.swizzle<1,1,3,3>() * _mm_movehl_ps(a, a);
  
  // _m11 = inv2x2(m11 - mul2x2(mul2x2(m12, inv22), m21)):
    // mul2x2(m12, inv22):
  | movaps xmm6, xmm5 // <- copy inv22
  | shufps xmm6, xmm6, _MM_SHUFFLE(0, 0, 2, 2)
  | movaps xmm7, xmm2 // <- copy xmm2/m12
  | movlhps xmm7, xmm7
  | mulps xmm6, xmm7
  | movaps xmm7, xmm5 // <- copy inv22
  | shufps xmm7, xmm7, _MM_SHUFFLE(1, 1, 3, 3)
  | movaps xmm8, xmm2  // <-!!!!!- We need xmm8 here, so save it to stack before!
  | movhlps xmm8, xmm8
  | mulps xmm7, xmm8
  | addps xmm6, xmm7 // <- mul2x2(m12, inv22)

  // free: xmm7

  // mul2x2(mul2x2(m12, inv22), m21):
  //        mul2x2(m12, inv22) = xmm6
  //                       m21 = xmm1
  // -> mul2x2(xmm6, xmm1)
  | movaps xmm7, xmm1 // <- copy xmm1/m21
  | shufps xmm7, xmm7, _MM_SHUFFLE(0, 0, 2, 2)
  | movaps xmm8, xmm6 // <- copy xmm6/mul2x2(m12, inv22)
  | movlhps xmm8, xmm8
  | mulps xmm7, xmm8
  | movaps xmm8, xmm1 // <- copy xmm1/m21
  | shufps xmm8, xmm8, _MM_SHUFFLE(1, 1, 3, 3)
  | movaps xmm9, xmm6  // <-!!!!!- We need xmm9 here, so save it to stack before!
  | movhlps xmm9, xmm9
  | mulps xmm8, xmm9
  | addps xmm7, xmm8 // <- mul2x2(mul2x2(m12, inv22), m21)

  // free: none (will overuse xmm8-xmm15)

  // m11 - mul2x2(mul2x2(m12, inv22), m21)
  // = xmm0 - xmm7
  // swap xmm0 and xmm7 with XOR swap
  // since we want the result to be in xmm7
  | xorps xmm0, xmm7
  | xorps xmm7, xmm0
  | xorps xmm0, xmm7
  // now subtract
  | subps xmm7, xmm0
  
  // inv2x2(m11 - mul2x2(mul2x2(m12, inv22), m21)):
  // = inv2x2(xmm7)
    // adj2x2(xmm7):
  | movaps xmm8, xmm7
  | shufps xmm8, xmm8, _MM_SHUFFLE(3, 1, 2, 0)
  | movaps xmm9, [r8] // <- load (0, -0, -0, 0)
  | xorps xmm8, xmm9 // <- _mm_xor_ps(m.swizzle<3,1,2,0>(), (0.0f, -0.0f, -0.0f, 0.0f));
    // det2x2(xmm7):
  | movaps xmm9, xmm7
  | shufps xmm9, xmm9, _MM_SHUFFLE(0, 0, 1, 1)
  | movaps xmm10, xmm7
  | shufps xmm10, xmm10, _MM_SHUFFLE(3, 3, 2, 2)
  | mulps xmm9, xmm10 // <- temp = m.swizzle<0,0,1,1>() * m.swizzle<3,3,2,2>();
  | movaps xmm10, xmm9
  | unpcklps xmm9, xmm9
  | unpckhps xmm10, xmm10
  | subps xmm9, xmm10 // <- _mm_sub_ps(_mm_unpacklo_ps(temp, temp), _mm_unpackhi_ps(temp, temp));
  | rcpps xmm9, xmm9 // <- det2x2(m).rcp();
  | mulps xmm8, xmm9 // <- _m11 = inv2x2(m11 - mul2x2(mul2x2(m12, inv22), m21))

  

  // restore xmm8, xmm9 (for the time being)
  | movaps xmm8, [r9]
  | movaps xmm9, [r9+16]
  | movaps xmm10, [r9+32]
}

static void matrix_transpose(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in first (xmm8-xmm11)
  // will store in either first or second (xmm12-xmm15)
  | movaps xmm0, xmm8
  | movaps xmm2, xmm8
  | movaps xmm1, xmm9
  | shufps xmm0, xmm1, _MM_SHUFFLE(2, 0, 2, 0)
  | shufps xmm2, xmm1, _MM_SHUFFLE(3, 1, 3, 1)
  | movaps xmm3, xmm10
  | movaps xmm5, xmm10
  | movaps xmm6, xmm11
  | shufps xmm3, xmm6, _MM_SHUFFLE(2, 0, 2, 0)
  | shufps xmm5, xmm6, _MM_SHUFFLE(3, 1, 3, 1)
  | movaps xmm1, xmm0
  | shufps xmm0, xmm3, _MM_SHUFFLE(2, 0, 2, 0)
  | movaps xmm4, xmm2
  | shufps xmm2, xmm5, _MM_SHUFFLE(2, 0, 2, 0)
  | shufps xmm1, xmm3, _MM_SHUFFLE(3, 1, 3, 1)
  | shufps xmm4, xmm6, _MM_SHUFFLE(3, 1, 3, 1)
  if (!storeIntoSecond) {
    // store back into first
    | movaps xmm8, xmm0
    | movaps xmm9, xmm2
    | movaps xmm10, xmm1
    | movaps xmm11, xmm4
  } else {
    // store back into second
    | movaps xmm12, xmm0
    | movaps xmm13, xmm2
    | movaps xmm14, xmm1
    | movaps xmm15, xmm4
  }
}

static void copy(dasm_State** Dst, char storeIntoSecond) {
if (!storeIntoSecond) {
  | movaps xmm8, xmm12
  | movaps xmm9, xmm13
  | movaps xmm10, xmm14
  | movaps xmm11, xmm15
} else {
  | movaps xmm12, xmm8
  | movaps xmm13, xmm9
  | movaps xmm14, xmm10
  | movaps xmm15, xmm11
}
}

static void copy_mem(dasm_State** Dst) {
  | mov r8, [rcx]
  | mov r9, [rcx+8]
  | add rcx, 16
  | movaps xmm0, [r8]
  | movaps [r9], xmm0
  | movaps xmm1, [r8+4*4]
  | movaps [r9+4*4], xmm1
  | movaps xmm2, [r8+4*8]
  | movaps [r9+4*8], xmm2
  | movaps xmm3, [r8+4*12]
  | movaps [r9+4*12], xmm3
}

static void load(dasm_State** Dst, char storeIntoSecond) {
  | mov r8, [rcx]
  | add rcx, 16
if (!storeIntoSecond) {
  | movaps xmm8, [r8]
  | movaps xmm9, [r8+4*4]
  | movaps xmm10, [r8+4*8]
  | movaps xmm11, [r8+4*12]
} else {
  | movaps xmm12, [r8]
  | movaps xmm13, [r8+4*4]
  | movaps xmm14, [r8+4*8]
  | movaps xmm15, [r8+4*12]
}
}

static void store(dasm_State** Dst, char fromSecond) {
  | mov r8, [rcx]
  | add rcx, 16
if (!fromSecond) {
  | movaps [r8], xmm8
  | movaps [r8+4*4], xmm9
  | movaps [r8+4*8], xmm10
  | movaps [r8+4*12], xmm11
} else {
  | movaps [r8], xmm12
  | movaps [r8+4*4], xmm13
  | movaps [r8+4*8], xmm14
  | movaps [r8+4*12], xmm15
}
}

static void linearProduct(dasm_State** Dst) {
  // vector is in xmm0, matrix in xmm8-xmm11
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | movaps xmm2, xmm0
  | shufps xmm2, xmm2, _MM_SHUFFLE(1, 1, 1, 1)
  | movaps xmm3, xmm0
  | shufps xmm3, xmm3, _MM_SHUFFLE(2, 2, 2, 2)
  | movaps xmm4, xmm0
  | shufps xmm4, xmm4, _MM_SHUFFLE(3, 3, 3, 3)
  | movaps xmm0, xmm8
  | mulps xmm0, xmm1
  | movaps xmm1, xmm9
  | mulps xmm1, xmm2
  | movaps xmm2, xmm10
  | mulps xmm2, xmm3
  | movaps xmm3, xmm11
  | mulps xmm3, xmm4
  | addps xmm0, xmm1
  | addps xmm2, xmm3
  | addps xmm0, xmm2
}

static void matrix_mul_matrix(dasm_State** Dst, char storeIntoSecond) {
  // requires:
  // left matrix in xmm8-xmm11 (aka. first)
  // right matrix in xmm12-xmm15 (aka. second)
  // will store in either first or second
  for (int i = 0; i < 4; i++) {
    // load column/vector from second
    if (i == 0) {
      | movaps xmm0, xmm12
    } else if (i == 1) {
      | movaps xmm0, xmm13
    } else if (i == 2) {
      | movaps xmm0, xmm14
    } else if (i == 3) {
      | movaps xmm0, xmm15
    }
    linearProduct(Dst);
    if (!storeIntoSecond) {
      // store into first
      if (i == 0) {
        | movaps xmm5, xmm0
      } else if (i == 1) {
        | movaps xmm6, xmm0
      } else if (i == 2) {
        | movaps xmm7, xmm0
      } else if (i == 3) {
        | movaps xmm8, xmm5
        | movaps xmm9, xmm6
        | movaps xmm10, xmm7
        | movaps xmm11, xmm0
      }
    } else {
      // store into second
      if (i == 0) {
        | movaps xmm12, xmm0
      } else if (i == 1) {
        | movaps xmm13, xmm0
      } else if (i == 2) {
        | movaps xmm14, xmm0
      } else if (i == 3) {
        | movaps xmm15, xmm0
      }
    }
  }
}

static void matrix_rotateX(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | movss xmm1, dword [rcx+4] // cos
  | add rcx, 16
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | mov r9, 0x80000000
  | movd xmm2, r9
  | shufps xmm2, xmm2, 0x0
  | xorps xmm2, xmm0 // -sin
  | movaps xmm3, xmm9
  | mulps xmm3, xmm1 // m1X * rm11
  | movaps xmm4, xmm10
  | mulps xmm4, xmm0 // m2X * rm12
  | addps xmm3, xmm4
  | movaps xmm4, xmm9
  | mulps xmm4, xmm2 // m1X * rm21
  | movaps xmm5, xmm10
  | mulps xmm5, xmm1 // m2X * rm22
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm9, xmm3
    | movaps xmm10, xmm4
  } else {
    | movaps xmm12, xmm8
    | movaps xmm13, xmm3
    | movaps xmm14, xmm4
    | movaps xmm15, xmm11
  }
}

static void matrix_rotateY(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | movss xmm1, dword [rcx+4] // cos
  | add rcx, 16
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | mov r9, 0x80000000
  | movd xmm2, r9
  | shufps xmm2, xmm2, 0x0
  | xorps xmm2, xmm0 // -sin
  | movaps xmm3, xmm8
  | mulps xmm3, xmm1 // m0X * rm00
  | movaps xmm4, xmm10
  | mulps xmm4, xmm2 // m2X * rm02
  | addps xmm3, xmm4
  | movaps xmm4, xmm8
  | mulps xmm4, xmm0 // m0X * rm20
  | movaps xmm5, xmm10
  | mulps xmm5, xmm1 // m2X * rm22
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm8, xmm3
    | movaps xmm10, xmm4
  } else {
    | movaps xmm12, xmm3
    | movaps xmm13, xmm9
    | movaps xmm14, xmm4
    | movaps xmm15, xmm11
  }
}

static void matrix_rotateZ(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  | movss xmm0, dword [rcx] // sin
  | movss xmm1, dword [rcx+4] // cos
  | add rcx, 16
  | shufps xmm0, xmm0, _MM_SHUFFLE(0, 0, 0, 0)
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | mov r9, 0x80000000
  | movd xmm2, r9
  | shufps xmm2, xmm2, 0x0
  | xorps xmm2, xmm0 // -sin
  | movaps xmm3, xmm8
  | mulps xmm3, xmm1 // m0X * rm00
  | movaps xmm4, xmm9
  | mulps xmm4, xmm0 // m1X * rm01
  | addps xmm3, xmm4
  | movaps xmm4, xmm8
  | mulps xmm4, xmm2 // m0X * rm10
  | movaps xmm5, xmm9
  | mulps xmm5, xmm1 // m1X * rm11
  | addps xmm4, xmm5
  if (!storeIntoSecond) {
    | movaps xmm8, xmm3
    | movaps xmm9, xmm4
  } else {
    | movaps xmm12, xmm3
    | movaps xmm13, xmm4
    | movaps xmm14, xmm10
    | movaps xmm15, xmm11
  }
}

static void matrix_identity(dasm_State** Dst) {
  // requires matrix to be in first (xmm8-xmm11)
  // will store in first
  | mov r9, 0x3f800000 // int representation of 1.0f
  | xorps xmm8, xmm8 // zero it out first
  | movd xmm8, r9
  | movaps xmm9, xmm8
  | shufps xmm9, xmm9, _MM_SHUFFLE(2, 1, 0, 3)
  | movaps xmm10, xmm9
  | shufps xmm10, xmm10, _MM_SHUFFLE(2, 1, 0, 3)
  | movaps xmm11, xmm10
  | shufps xmm11, xmm11, _MM_SHUFFLE(2, 1, 0, 3)
}

static void matrix_scale(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  // get scale factor (x, y, z, 1)
  | movaps xmm0, [rcx]
  | add rcx, 16
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  if (!storeIntoSecond) {
    | mulps xmm8, xmm1
  } else {
    | movaps xmm2, xmm8
    | mulps xmm2, xmm1
    | movaps xmm12, xmm2
  }
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(1, 1, 1, 1)
  if (!storeIntoSecond) {
    | mulps xmm9, xmm1
  } else {
    | movaps xmm2, xmm9
    | mulps xmm2, xmm1
    | movaps xmm13, xmm2
  }
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(2, 2, 2, 2)
  if (!storeIntoSecond) {
    | mulps xmm10, xmm1
  } else {
    | movaps xmm2, xmm10
    | mulps xmm2, xmm1
    | movaps xmm14, xmm2
    | movaps xmm15, xmm11
  }
}

static void matrix_translate(dasm_State** Dst, char storeIntoSecond) {
  // requires matrix to be in xmm8-xmm11 (aka. first)
  // will store in either first or second (xmm12-xmm15)
  // get translation (x, y, z, 0)
  | movaps xmm0, [rcx]
  | add rcx, 16
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(0, 0, 0, 0)
  | movaps xmm2, xmm8
  | mulps xmm2, xmm1 // m0X * x
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(1, 1, 1, 1)
  | movaps xmm3, xmm9
  | mulps xmm3, xmm1 // m1X * y
  | addps xmm2, xmm3 // +
  | movaps xmm1, xmm0
  | shufps xmm1, xmm1, _MM_SHUFFLE(2, 2, 2, 2)
  | movaps xmm3, xmm10
  | mulps xmm3, xmm1 // m2X * z
  | addps xmm2, xmm3 // +
  | movaps xmm1, xmm11
  | addps xmm2, xmm1 // + m3N
  if (!storeIntoSecond) {
    | movaps xmm11, xmm2
  } else {
    | movaps xmm12, xmm8
    | movaps xmm13, xmm9
    | movaps xmm14, xmm10
    | movaps xmm15, xmm2
  }
}

static void matrix_translationRotateScale(dasm_State** Dst) {
 // load (qx, qy, qz, qw) into xmm0
 | movaps xmm0, [rcx+16]
 // compute dqX
 | movaps xmm1, xmm0
 | addps xmm1, xmm1 // <- dqX
 // compute qNN
 | movaps xmm2, xmm1
 | mulps xmm2, xmm0
 | mov r8, 0x80000000 // sign mask
 | movd xmm3, r8
 | shufps xmm3, xmm3, _MM_SHUFFLE(0, 0, 0, 0)
 | xorps xmm2, xmm3 // * -1 <- qNN
 // compute q0N
 | movaps xmm3, xmm0
 | shufps xmm3, xmm3, _MM_SHUFFLE(0, 3, 2, 1)
 | movaps xmm4, xmm1
 | shufps xmm4, xmm4, _MM_SHUFFLE(0, 0, 0, 0)
 | mulps xmm3, xmm4 // <- q0N
 // load (tx, ty, tz, 1) directly into xmm11
 | movaps xmm11, [rcx]
 // compute q12-23
 | movaps xmm4, xmm0
 | movaps xmm5, xmm1
 | shufps xmm4, xmm4, _MM_SHUFFLE(2, 3, 3, 2)
 | shufps xmm5, xmm5, _MM_SHUFFLE(2, 2, 1, 1)
 | mulps xmm4, xmm5 // <- q12-23
 // Make (1, -1, 1, 1) ready in xmm5
 // 3f800000 - int pattern of 1
 // bf800000 - int pattern of -1
 | mov r8, rsp
 | and r8, -16
 | sub r8, 32
 | mov dword [r8], 0x3f800000
 | mov dword [r8+4], 0xbf800000
 | mov dword [r8+8], 0x3f800000
 | mov dword [r8+12], 0x3f800000
 | movaps xmm5, [r8]
 // compute m1N = xmm9
 // load (sx, sy, sz, 0) into xmm0
 | movaps xmm0, [rcx+32] 
 | movaps xmm6, xmm4
 | shufps xmm6, xmm2, _MM_SHUFFLE(2, 2, 2, 0)
 | mulps xmm6, xmm5
 | movaps xmm7, xmm3
 | shufps xmm7, xmm2, _MM_SHUFFLE(0, 0, 0, 2)
 | addps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 1, 1, 1)
 | mulps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 1, 3, 3)
 | addps xmm6, xmm7
 | shufps xmm6, xmm6, _MM_SHUFFLE(3, 0, 2, 1)
 | movaps xmm9, xmm6 // <- m1N
 // compute m2N = xmm10
 | movaps xmm6, xmm3
 | shufps xmm6, xmm2, _MM_SHUFFLE(0, 0, 2, 1)
 | mulps xmm6, xmm5
 | movaps xmm7, xmm4
 | shufps xmm7, xmm2, _MM_SHUFFLE(1, 1, 0, 1)
 | addps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 2, 2, 2)
 | mulps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 2, 3, 3)
 | addps xmm6, xmm7
 | movaps xmm10, xmm6
 // compute m0N = xmm8
 | movaps xmm6, xmm4
 | shufps xmm6, xmm2, _MM_SHUFFLE(2, 2, 1, 2)
 | mulps xmm6, xmm5
 | movaps xmm7, xmm3
 | shufps xmm7, xmm2, _MM_SHUFFLE(1, 1, 1, 0)
 | addps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 0, 0, 0)
 | mulps xmm6, xmm7
 | movaps xmm7, xmm0
 | shufps xmm7, xmm7, _MM_SHUFFLE(3, 0, 3, 3)
 | addps xmm6, xmm7
 | shufps xmm6, xmm6, _MM_SHUFFLE(3, 1, 0, 2)
 | movaps xmm8, xmm6
 // advance rcx pointer
 | add rcx, 48
}

static void vector_negate(dasm_State** Dst) {
  | mov r8, [rcx]
  | add rcx, 16
  | movaps xmm0, [r8]
  | mov r9, 0x80000000
  | movd xmm1, r9
  | shufps xmm1, xmm1, 0x0
  | xorps xmm0, xmm1
  | movaps [r8], xmm0
}

static void prologue(dasm_State** Dst) {
  | push rbp
  | mov rbp, rsp
  | sub rsp, 16*10
}

static void epilogue(dasm_State** Dst) {
  | mov rsp, rbp
  | pop rbp
  | ret
}

batch_func_t codegen(const unsigned char* opcodes, int opcodesLength, size_t* codeSize) {
  dasm_State* state;
  dasm_State** Dst = &state;
  int status;
  void* code;
  DWORD dwOld;
  void* global_labels[GLOB__MAX];
  dasm_init(&state, DASM_MAXSECTION);
  dasm_setupglobal(&state, global_labels, GLOB__MAX);
  dasm_setup(&state, actionlist);
  prologue(Dst);
  for (int i = 0; i < opcodesLength; i++) {
    unsigned char opcode = opcodes[i];
    char second = (opcode & OPCODE_MASK_SECOND) == OPCODE_MASK_SECOND;
    opcode &= 0x7F;
    switch (opcode) {
    case OPCODE_MATRIX_MUL_MATRIX:
      matrix_mul_matrix(&state, second); break;
    case OPCODE_MATRIX_TRANSPOSE:
      matrix_transpose(&state, second); break;
    case OPCODE_MATRIX_IDENTITY:
      matrix_identity(&state); break;
    case OPCODE_MATRIX_ROTATEX:
      matrix_rotateX(&state, second); break;
    case OPCODE_MATRIX_ROTATEY:
      matrix_rotateY(&state, second); break;
    case OPCODE_MATRIX_ROTATEZ:
      matrix_rotateZ(&state, second); break;
    case OPCODE_MATRIX_TRANSLATE:
      matrix_translate(&state, second); break;
    case OPCODE_MATRIX_SCALE:
      matrix_scale(&state, second); break;
    case OPCODE_MATRIX_INVERT:
      matrix_invert(&state, second); break;
    case OPCODE_MATRIX_TRANSLATION_ROTATE_SCALE:
      matrix_translationRotateScale(&state); break;
    case OPCODE_VECTOR_NEGATE:
      vector_negate(&state); break;
    case OPCODE_STORE:
      store(&state, second); break;
    case OPCODE_LOAD:
      load(&state, second); break;
    case OPCODE_COPY:
      copy(&state, second); break;
    case OPCODE_COPY_MEM:
      copy_mem(&state); break;
    default:
      break;
    }
  }
  epilogue(Dst);
  status = dasm_link(&state, codeSize);
  code = mmap(0, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  status = dasm_encode(&state, code);
  mprotect(code, *codeSide, PROT_READ | PROT_EXEC);
  dasm_free(&state);
  return (batch_func_t) code;
}

int free_code(void* code, size_t codeSize) {
  return munmap(code, codeSize);
}
